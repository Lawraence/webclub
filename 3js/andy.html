<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title></title>
    <style>
        body {
            margin: 0;
        }
        canvas{
            width: 100%;
            height: 100%;
        }

    </style>
</head>

<body>
    <script src="js/three.js"></script>
    <script> 
        const scene = new THREE.Scene(); 
        const camera = new THREE.PerspectiveCamera(125, window.innerWidth / window.innerHeight, 0.1, 1000); 
        const renderer = new THREE.WebGLRenderer(); 
        

        renderer.setSize(window.innerWidth, window.innerHeight); 
        //setSize(window.innerWidth/2, window.innerHeight/2, false) will render your app at half resolution, given that your <canvas> has 100% width and height.

        document.body.appendChild(renderer.domElement); 

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

        renderer.setPixelRatio(window.devicePixelRatio);

        //Create a DirectionalLight and turn on shadows for the light
        const light = new THREE.DirectionalLight( 0xffffff, 1 );
        light.position.set( 0, 0, 1 ); //default; light shining from top
        light.castShadow = true; // default false
        scene.add( light );

        //Set up shadow properties for the light
        light.shadow.mapSize.width = 512; // default
        light.shadow.mapSize.height = 512; // default
        light.shadow.camera.near = 0.5; // default
        light.shadow.camera.far = 500; // default

        const cubeGeo = new THREE.BoxGeometry(1, 1, 1); 
        const cubeMat = new THREE.MeshLambertMaterial({ color: 0xffffff }); 
        const cube = new THREE.Mesh(cubeGeo, cubeMat); 
        cube.recieveShadow = true;
        cube.castShadow = true;
        scene.add(cube); 


        const ballGeo = new THREE.SphereGeometry(0.5, 32, 32);
        const ballMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
        const ball = new THREE.Mesh(ballGeo, ballMat);
        ball.receiveShadow = true;
        ball.castShadow = true;
            
        ball.position.set(1.5, 0, 0);
        scene.add(ball);

        scene.add(camera);

        renderer.shadowMap.enabled = true;

        camera.position.z = 5; 

        const halfSphereGeo = new THREE.SphereGeometry(1, 32, 32, 0, Math.PI);
        const halfSphereMat = new THREE.MeshLambertMaterial({ color: 0xff0000});
        const halfSphere = new THREE.Mesh(halfSphereGeo, halfSphereMat);
        halfSphere.receiveShadow = true;
        halfSphere.castShadow = true;
        
        halfSphere.position.set(-2, 0, 0);
        scene.add(halfSphere);

        let angle = 0; // Initialize angle for rotation

        function animate() { 
            requestAnimationFrame(animate); 

            cube.rotation.x += Math.random() * 0.1; 
            cube.rotation.y += Math.random() * 0.1; 
            cube.rotation.z += Math.random() * 0.1; 
            angle += Math.random() * 0.1; ;


            ball.position.x = Math.cos(angle) * 1.5;
            ball.position.z = Math.sin(angle) * 1.5;
            ball.position.y = Math.sin(angle) * 1.5;

            halfSphere.position.x = Math.sin(angle) * 1;
            halfSphere.position.z = Math.sin(angle) * 1;
            halfSphere.position.y = Math.cos(angle) * 1;


            renderer.render(scene, camera); 
        }
        animate(); 


    </script>
</body>

</html>
